#### 题目描述

圣诞老人想将礼物发送给孩子们。他有一堆价值$n$的礼物，从$1$到$n$编号；最上面的礼物编号为$a_1$，下一个礼物是$a_2$，依此类推；最底下的编号为$a_n$。所有编号都是不同的。

圣诞老人列出了他需要发送的$m$个**不同**的礼物：$b_1,b_2,...,b_m$，他将**按照列表中的顺序**送出这些礼物。

要送出某一件礼物，圣诞老人必须先移除其上方的所有礼物，取出该礼物并将所有已移除的礼物重新放回礼物栈中。因此，如果在圣诞老人要发送的礼物上方有$k$件礼物，他需要花$2k + 1$秒来完成。幸运的是，圣诞老人可以加快整个过程的速度，当他将礼物重新放回礼物栈时，他可以将它们重新排序（下方的礼物不会受到影响）。

给定礼物清单和初始礼物栈的情况，若每次都以最佳方式对其进行重新排序，求发送所有礼物所需的最短时间是多少。

#### 输入格式

第一行包含两个整数$n$和$m$，代表礼物栈中的礼物数量和圣诞老人想要发送的礼物数量。

第二行包含$n$个整数$a_1,a_2,...,a_n(1 \le a_i \le n)$，代表礼物栈中礼物的顺序，按照从栈顶到栈底的顺序排序。

第三行包含$m$个整数$b_1,b_2,...,b_m(1 \le b_i \le n)$，代表圣诞老人送出礼物的顺序。

#### 输出格式

输出一个整数，代表圣诞老人在每次将礼物放回堆栈时以最佳方式对礼物进行重新排序的情况下，圣诞老人送出礼物的最短时间。

#### 样例

**样例输入1**

```
3 3
3 1 2
3 2 1
```

**样例输出1**

```
5
```

**样例输入2**

```
7 2
2 1 7 3 4 5 6
3 1
```

**样例输出2**

```
8
```

#### 数据范围与提示

对60%的数据，$1 \le m \le n \le 10^3$

对100%的数据，$1 \le m \le n \le 10^5$



从b数组中第一个元素开始，找到第一个在栈中位于其下面的礼物的下标，继续此过程直到找到栈底部的那个礼物为止，得到一个链表。对于这个链表中的元素，因为该深度是整个过程中第一次被达到，必须把上面的所有礼物都取出来。对于不在这个链表中的元素，因为之前已经达到过比这更深的深度了，可以通过最优排列让该元素出现在栈顶，只要1次操作。





```c++
#include <bits/stdc++.h>
using namespace std;
inline int read()
{
    int x = 0, k = 1;
    char c = getchar();
    while (c < '0' || c > '9') {
        if (c == '-')
            k = -1;
        c = getchar();
    }
    while (c >= '0' && c <= '9') {
        x = (x << 3) + (x << 1) + c - '0';
        c = getchar();
    }
    return x * k;
}
int a[100005], a_inv[100005], b[100005];
int nxt[100005];
int main()
{
    int n = read(), m = read();
    for (int i = 1; i <= n; i++) {
        a[i] = read();
        a_inv[a[i]] = i;
    }
    for (int i = 1; i <= m; i++) 
        b[i] = read();
    for (int i = 1; i <= m && i;) {
        for (int j = i + 1; j <= m; j++) {
            if (a_inv[b[j]] > a_inv[b[i]]) {
                nxt[i] = j;
                break;
            }
        }
        i = nxt[i];
    }

    int first = 1;
    long long ans = 0;
    for (int i = 1; i <= m; i++) {
        if (nxt[i] != 0) {
            first = i;
            break;
        }
    }
    for (int i = first; i; i = nxt[i]) {
        ans += 2 * (a_inv[b[i]] - i) + 1;
    }
    for (int i = 1; i <= m;i++){
        if(nxt[i]==0)
            ++ans;
    }
    --ans; //链表尾被多算了一次
    cout << ans;
    return 0;
}
```

